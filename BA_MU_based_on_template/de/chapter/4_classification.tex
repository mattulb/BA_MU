\chapter{Klassifikation Homomorpher Kryptosysteme}
\section{Aufteilungen}
\section{Autocrypt} \cite{tople2013autocrypt}
Problemstellung: Server sind ständig durch Angriffe bedroht die bis hin zu ihrer kompletten Übernahme geraten können. Um Datendiebstahl und Vertraulichkeitsverletzungen vorzubeugen ist es ratsam nur mit verschlüsselten Datenbeständen zu arbeiten. Ein IT-System oder Programm so anzupassen, dass es auf verschlüsselten Daten korrekt arbeitet wollen die Wissenschaftler automatisieren indem sie die Arbeit der Programmtransformation mit einem Compiler abwickeln: Autocrypt.

Der Server läuft als virtuelle Maschine und Inhalte werden außerhalb der unvertrauten VM auf einem keyserver verschlüsselt. Autocrypt bestimmt automatisch benötigte Verschlüsselungsdatentypen für die Variablen und konvertiert zwischen diesen im Programmablauf her durch einfügen von hypercalls. Die Verschlüsselungsdatentypen werden gewählt nach der Verknüpfung die sie zu Verfügung stellen. Wenn also im Ursprungscode Additionen von zwei Variablen durchgeführt werden, dann werden zunächst Paillerverschlüsselungsdatentypen erzeugt. Wird das Ergebnis allerdings später multipliziert, dann muss der Datentyp konvertiert werden zu einem Elgamalverschlüsselungsdatentyp.

Bei der Entwicklung von Autocrypt sollen alle Rechenoperationen privacy-preserving sein. Als Transformationstool ist eine Integrität der Daten auf denen gerechnet wird daher nicht berücksichtigt worden.

\textbf{Kategorisierungskriterien}: Pailler wurde wegen seiner Homomorphie und Additionsverknüpfung verwendet ($\rightarrow$ additiv-homomorph). Analoges Argument für Elgamal. Zwischen diesen beiden Verfahren wird hin und her konvertiert, da dies schneller ist als \textit{ein} vollhomomorphes Verfahren ($\rightarrow$ Klasse schneller Verfahren). Weiter ist Pailler flexibel einsetzbar für die Addition von Zahlen byteweiese oder bitweise. Letzteres ermöglicht die Konstrution eines homomorphen XOR Operators. ($\rightarrow$ homomorph XOR)

\textbf{Malleability}: Die Autotoren haben als Zielsetzung die unerlaubte Kenntnisnahme von Daten auf dem Server zu unterbinden. Eine Überprüfung der Integrität von Rechenoperationen der von Autocrypt konvertierten Programmbestandteile ist daher kein Fokus der Arbeit [p. 4].

\section{Machine Learning Classification over encrypted data} \cite{bost2015machine}
Problemstellung: Es soll ein privacy-preserving Maschinenlernenverfahren erstellt werden, bei dem sowohl die zu klassifizierenden Daten als auch die Klassifiziererdesigns vertraulich bleiben. Es wird eine Bibliothek konstruiert, aus der Modular beliebige privacy-preserving Klassifizierer erstellt werden können.

In einem ersten Ansatz wurde überlegt privacy-preserving mit Secure Multiparty Computation umzusetzen, welches sich jedoch als zu langsam herrausgestellt hat. Aus dem gleichen Grund wird auch auf den Einsatz von vollhomomorpher Verschlüsselung verzichtet. Es ist schneller mit für Klassifizierungsverfahren spezialisierten Protokollen zu arbeiten. 

Es wird wie in \cite{tople2013autocrypt} XOR mit Pailler simuliert. Zusätzlich wird ein privates Skalarprodukt auf Basis von Pailler berechnet.
Gegeben seien die Vektoren $x=(x_1,\ldots,x_n)$ und $y=(y_1,\ldots,y_n)$  wobei alle Einträge Klartexte sind. Das mit pub Paillierverschlüsselte Skalarprodukt ist dann:
\begin{equation}
Enc_{pub}(\left\langle x,y\right\rangle )=\prod_i Enc_{pub}(y_i)^{x_i} \text{ mod } N^2
\end{equation}

Eine weitere Tatsache die im Paillerkryptosystem ausgenutzt wird ist der Klartextraum ungefähr $2^{1024}$ bit ist. Anstelle von lediglich Integern können Floatzahlen mit Pailler verschlüsselt werden, wenn man die IEEE 754 floating point Darstellung verwendet welche große Exponenten benötigt.

In dieser Arbeit wurde auch eine leveled vollhomomorphe Verschlüsselung (HELib) verwendet, jedoch der Umfang und die Gründe dafür bleiben ohne nähere Erläuterung [p. 4].

\textbf{Kategorisierungskriterien}: Es wurden die Kryptosysteme von Paillier und Goldwasser–Micali verwendet. Beide Aufgrund ihrer schnelleren Performance und der mathematischen Verknüpfung sie anbieten. ($\rightarrow$ additiv-homomorph) ($\rightarrow$ xor-homomorph). Analog zur unverschlüsselten Konstruktion von Gleitkommazahlen aus ganzen Zahlen kann mit  Pailler ein Operator für die homomorphe Addition von Gleitkommazahlen konstruiert werden. ($\rightarrow$ floatingpoint-additiv-homomorph)

\textbf{Malleability}: Es werden die homomorphen Kryptosysteme ledglich zum Rechnen im Chiffreraum verwendet. Ein Angriff der Malleability ausnutzt wird nicht betrachtet. Dies ist nachvollziehbar, da hier ein deterministischer Algorithmus abgearbeitet wird.

\section{Privacy Preserving Matrix Factorization} \cite{nikolaenko2013privacy}
Bei der Generierung von userspezifischen Empfehlungen anhand vorheriger Wahlen eines Users ist Matrizenfaktorisierung ein weit verbreitetes Verfahren. Um dieses privacy-preserving zu machen soll ein System designt werden, welches Empfehlung geben kann ohne die Userbewertungen zu lernen.

Bei dem Design wird aus Performancegründen hash-ElGamal verwendet um verschlüsselte Wertungen zu maskieren für die Einheit, welche im Besitz des privaten Schlüssels ist. In dem Design bekommt das Recommendersystem (RecSys) vom User ein mit dem öffentlichen Schlüssel von Cryptoserviceprovider (CSP) verschlüsseltes Rating $c$. Damit der CSP dies Rating nicht aufdecken kann, addiert RecSys einen zufälligen Wert $\mu$ auf das Rating. CSP erhält $c'=c+\mu$.

\textbf{Kategorisierungskriterien}: Es wurde hash-ElGamal verwendet wegen seiner schnelleren Performance gegenüber Paillier und seiner Additivität ($\rightarrow$ additiv-homomorph)

\textbf{Malleability}: Bei dem Design wird von einem honest-but-curious Angreifer ausgegangen. Also könnte RecSys aus Neugierde $\mu=0$ addieren und so CSP ermöglichen alle Userratings zu lernen. Im HBC-Modell dürfen RecSys und CSP jedoch nicht vom Protokoll abweichen und könnten daher nicht kooperativ diese Information abschöpfen, denn CSP weiß nicht, dass RecSys eine Nulladdition durchführt welches die Maskierung aufhebt.

\subsection{Efficient and Secure Comparison for On-Line Auctions}
Ivan Damgard et al. stellen in \cite{damgaard2007efficient} ein neues additives Kryptosystem vor um schnelle vergleiche einer öffentlich bekannten Zahl $x$ und einer geheimen Zahl $m$ durchzuführen die auf einem Server und einem Hilfsserver verteilt ist. Bei der on-line Versteigerung steht $x$ für das momentane Höchstgebot, während $m$ für das private mögliche Höchstgebot steht. Sie haben dieses Kryptosystem für ihren Anwendungsfall designt, da sie einen möglichst kleinen Klartextraum haben wollen. Die Verwendung eines kleinen Klartextraums hat zum Vorteil, dass mit kleineren Exponenten gerechnet wodurch ihr Verfahren an Effizienz im Vergleich gegenüber anderen Ansätzen gewonnen hat. 

In ihrem Vergleich $m\leq x$ ist letztere Zahl öffentlich, jedoch ist das Verfahren erweiter bar, das beide Eingabeparameter geheim sind. 

\textbf{Kategorisierungskriterien:} additiv-homomorph, kleiner Klartextraum

\textbf{Malleability:} Das vorgestellen Kryptosystems wurde nicht auf Malleability untersucht obwohl bösartige Anfragen mögliche währen, da von einem honest-but-curious Angreifermodell ausgegangen wird. Ein Teilnehmer kann somit falsche Höchstgebote abgeben, jedoch gewinnt man dadurch keinen Vorteil. Entweder wird man früher aus dem Gebotsverfahren geschmissen oder er kann nach dem Gebotsverfahren feststellen ob der Betreiber die Vergleiche inkorrekt durchgeführt hat.  

\subsection{Fingerprinting Protocol for Images Based on Additive Homomorphic Property}
\cite{kuribayashi2005fingerprinting}
Das vorgestellte Protocol wurde unter dem Hintergrund eingeführt, da bisher bekannte Lösungen entweder eine zu langsame Verschlüsselungsrate hatten oder das Einsetzen des Wasserzeichens zu aufwendig ist. Es ein homomorphes public-key Kryptosystem eingesetzt um asymmetrische Fingerprints zu erzeugen. Dies ist notwendig, da bei symmetrischen Fingerprinting, der Verkäufer ein Benutzerspezifisches Wasserzeichen erzeugt und somit auch einen rechtmäßigen Käufer eine Raubkopie unterstellen könnte. 


\subsection{Secure Computation mit SMC oder HE}
In den Studien \cite[p.420]{damgaard2007efficient} und \cite[p.2]{sadeghi2009efficient} wurden zwei Techniken identifiziert um Funktionen sicher zu berechnen: Secure Multi-Party Computation und Homomorphe Verschlüsselung. Dabei kommen beide Studien unabhängig voneinander zu den gleichen Schlüssen über die Vorzüge der jeweiligen Verfahren:
\begin{itemize}
	\item SMC Vorteil: viel Kommunikation
	\item SMC Nachteil: geringe Runden- und Berechenkomplexität
	\item HE Vorteil: geringe Kommunikation
	\item HE Nachteil: hohe Runden- und Berechenkomplexität
	
\end{itemize}

% Wichtig für eine sehr gute Note ist die Fähigkeit zur Bewertung der Kryptosysteme zu ihrer möglichen Umsetzung für Pseudonymisierungsverfahren.




\begin{center}
	\begin{tabular}{ | l | l | l | p{5cm} |}
		\hline
		Kryptosystem & hom. Operator & sim. Operator & modi \\ \hline
		Pailler & $+$ & XOR, $\left\langle\cdot,\cdot \right\rangle$  & bitwise, bytewise, float \\ \hline
		ElGamal & $\cdot$ & -  & - \\ \hline
		hash-ElGamal & XOR &  - & - \\ \hline
		Goldwasser-Micaeli & XOR & & \\ \hline
		BGV (HELib) & vollhom. & any& \\ \hline
	\end{tabular}
\end{center}